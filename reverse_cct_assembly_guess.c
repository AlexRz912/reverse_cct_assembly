#include <windows.h>

#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <conio.h>

#include "./src/backend/data/constants.h"
#include "./src/backend/data/structs.h"
#include "./src/backend/game_logic/game_logic.h"
#include "./src/backend/utils/utils.h"
#include "./src/backend/game_logic/handle_sound/sound.h"
#include "./src/backend/game_logic/handle_inputs/inputs.h"

/**
 * Message to you: IT, Cybersecurity managers and Devops Engineers.
 * 
 * 
 * This is an attempt at describing the assembly code of the main function of a game I recently created.
 * https://github.com/AlexRz912/reverse_cct
 * 
 * I want to understand assembly code generated by the compiler from C code, so as to 
 * understand how assembly code works in general, and how to reverse engineer programs
 * 
 * At the moment, I've got a good understanding of general purpose registers, EFLAGS and stack usage, 
 * how to call functions and use arguments, and calling conventions.
 * 
 * According to AIs, I lack capacity to reason strictly according to the ABI, and 
 * the understanding of different compiler optimizations and how they affect the generated assembly code.
 * 
 * The compilation of this file is done with 0 optimization, as if -O0 flag was given to the compiler.
 * 
 * WHICH I'M NOT GOING TO LEARN AS I'M NOT TRYING TO SPECIALIZE FOR NOW.
 */

// call main
int main() {
    srand(time(NULL));
    // push ebp, (4 bytes)
    // mov ebp, esp (ebp now previous stack pointer)
    // push esi (callee-saved)
    // push edi (callee-saved)
        // push 0 (4 bytes, argument passé à time)
        // call time
            // push ebp, // Context from esp at line 19
            // mov ebp, esp
            // implementation of time
            // mov esp, ebp
            // pop ebp // returns context to ebp (same value as line 19)
            // ret
        // push eax
        // call srand!
            // push ebp, (4 bytes)
            // mov ebp, esp ( esp qui pointe 4 bytes plus haut que ebp)
            // implementation of srand
            // mov esp, ebp
            // pop ebp
            // ret

    // xor eax, eax
    // mov esi, dword ptr ds:[data segment + MAX_CCT_INTERVAL_MS]
    // mov edi, dword ptr ds:[data segment + MIN_CCT_INTERVAL_MS]
    int startIntervalMs = MAX_CCT_INTERVAL_MS; 
    int minIntervalMs   = MIN_CCT_INTERVAL_MS;
    // call initGame
    initGame();
        // push ebp
        // mov ebp, esp
        // push 28
        // call FID_CONFLICT:<lambda_invoker_cdecl>  (implementation of malloc)
        // sub esp, 0x04 (stack alignment)
        // mov dword ptr [ebp + 8], eax
        // mov edx, dword ptr [ebp + 8]
        // mov esp, ebp
        // pop ebp
        // ret
    // call isAllocFailing
    if (isAllocFailing()) {
        // push ebp
        // mov ebp, esp
        // implementation of isAllocFailing
        // mov esp, ebp
        // pop ebp
        // ret
    // cmp eax, 0 (return value of isAllocFailing in eax)
    // jz .LContinue
        // mov eax, dword ptr ds:[data segment + "program failure"]
        // call printf
        printf("program failure");
        return 1;
        // xor eax, eax
        // mov eax, 1
        // mov esp, ebp
        // pop ebp
        // ret
    }
    // .LContinue:
    // push esi : MAX_CCT_INTERVAL_MS
    // push edi : MIN_CCT_INTERVAL_MS
    // call getGame
    getGame(startIntervalMs, minIntervalMs);
        // push ebp
        // mov ebp, esp
        // implementation of getGame
        // mov esp, ebp
        // pop ebp

    // mov dword ptr [ebp-12], 0
    // mov dword ptr [ebp-8], 0
    // mov dword ptr [ebp-4], 1
    int previousAnswerCorrect = 1;
    int validStreak = 0; 
    int errorStreak = 0;

    // .LWhile:
    while(1) 
    {
        // mov eax, dword ptr ds:[data segment + "correct answer"]
        // test [ebp - 4], 1
        // jz .PrintCorrectAnswer
        // mov eax, dword ptr ds:[data segment + "wrong answer"]
        // push eax
        // call printf
        if (previousAnswerCorrect) { printf("correct answer\n"); }
        else { printf("wrong answer\n"); }
        // push dword ptr [ebp-12]
        // call streakReachedMax
            
        if (streakReachedMax(errorStreak)) 
        {
            // push ebp
            // mov ebp, esp
            // cmp dword ptr [ebp + 8], 4
            // jne .Lfalse
            // and [ebp + 8], 0 (reset errorStreak to 0)
                errorStreak = 0;
            // push edx (reverseCCTGame)
            // call increaseInterval
                increaseInterval(reverseCCTGame);
                // push ebp
                // mov ebp, esp
                // mov eax, dword ptr [ebp + 8] (argument reverseCCTGame)
                // add dword ptr [eax + 24], 0x64  (increment interval)
                // mov esp, ebp
                // pop ebp
                // ret
            // .Lfalse:
            // mov esp, ebp
            // pop ebp
            // ret
        }
        // push dword ptr [ebp - 8]
        // call streakReachedMax
        if (streakReachedMax(validStreak)) 
        {
            // push ebp
            // mov ebp, esp
            // cmp dword ptr [ebp + 8], 4
            // jne .Lfalse
            // and [ebp + 8], 0 (reset validStreak to 0)
                validStreak = 0;
            // push edx (reverseCCTGame)
            // call decreaseInterval
                decreaseInterval(reverseCCTGame);
                // push ebp
                // mov ebp, esp
                // mov eax, dword ptr [ebp + 8] (argument reverseCCTGame)
                // sub dword ptr [eax + 24], 0x64  (decrement interval)
                // mov esp, ebp
                // pop ebp
                // ret
            // .Lfalse:
            // mov esp, ebp
            // pop ebp
            // ret
        }
        // call getNextCCTNumber
        getNextCCTNumber();
            // push ebp
            // mov ebp, esp
            // implementation for getNextCCTNumber
            // mov esp, ebp
            // pop ebp
            // ret
        // call addNextToPrevious
        addNextToPrevious();
            // push ebp
            // mov ebp, esp
            // implementation for addNextToPrevious
            // mov esp, ebp
            // pop ebp
            // ret
        int noGoSignal = getRand(4, 0);
        // push 0
        // push 4
        // call getRand
            // push ebp
            // mov ebp, esp
            // implementation for getRand
            // mov esp, ebp
            // pop ebp
            // ret
        // mov ecx, eax
        // push [edx + 12] (newNum)
        // call playNumber
        playNumber(reverseCCTGame->newNum);
            // push ebp
            // mov ebp, esp
            // implementation for playNumber
            // mov esp, ebp
            // pop ebp
            // ret
        // mov dword ptr [edx + 20], -1
        reverseCCTGame->answer = -1;
        // cmp ecx, 3
        // jne .LnoNoGoSignal
        if (noGoSignal == 3) {
            // push ds:[MIN_NOGO_SIGNAL] 
            // push ds:[MAX_NOGO_SIGNAL]
            // call getRand
                // push ebp
                // mov ebp, esp
                // implementation for getRand
                // mov esp, ebp
                // pop ebp
                // ret
            // mov esi, eax
            // mov dword ptr eax, [edx + 24]
            // mov dword ptr [ebp - 16], eax
            // sub dword ptr [ebp - 16], esi
            // mov eax, dword ptr [ebp - 16]
            // cmp eax, 0
            // jge .LpositiveTimeBeforeSignal
            // mov eax, 0
            // .LpositiveTimeBeforeSignal:
                // push eax
                // call Sleep
                // call captureInputDuringSleep
                // call playNoGoSound
                // push esi
                // call Sleep
                // call captureInputDuringSleep
            int nogoTimeBeforeEnd = getRand(MAX_NOGO_SIGNAL, MIN_NOGO_SIGNAL);
            int timeBeforeSignal = reverseCCTGame->interval - nogoTimeBeforeEnd;
            if (timeBeforeSignal < 0) timeBeforeSignal = 0; 
            
            Sleep(timeBeforeSignal);
            captureInputDuringSleep();
            
            playNoGoSound();

            Sleep(nogoTimeBeforeEnd);            
            captureInputDuringSleep();
        } else {
            // .LnoNoGoSignal:
            // push [edx + 24] (interval)
            // call Sleep
            // call captureInputDuringSleep
            Sleep(reverseCCTGame->interval);
            captureInputDuringSleep();
        }

        // call slideNumbers (return adress pushed)
        slideNumbers();
            // (on slideNumbers stack space)
            // push ebp
            // mov ebp, esp
            // implementation for slideNumbers
            // mov esp, ebp
            // pop ebp
            // ret
        
        // push [ebp-16] ; noGoSignal
        // call noGoSignalHappened
        if ((!noGoSignalHappened(noGoSignal) && isCorrectAnswer((reverseCCTGame->addition % 10), reverseCCTGame->answer)) || 
        (noGoSignalHappened(noGoSignal) && userDidNotAnswer(reverseCCTGame->answer)))
        {   
            // push ebp
            // mov ebp, esp
            // implementation for noGoSignalHappened
            // mov esp, ebp
            // pop ebp
            // ret
        // test eax, eax
        // jnz .LCheckCorrectAnswer
        // jmp .LElse

        // .LCheckCorrectAnswer:
            // push [edx + 8]  (reverseCCTGame->answer)
            // mov eax, dword ptr [edx + 4] (reverseCCTGame->addition)
            // mov ecx, 10
            // cdq  
            // idiv ecx       (eax = addition % 10)
            // push eax
            // push dword ptr [edx + 8] (answer)
            // call isCorrectAnswer
                // push ebp
                // mov ebp, esp
                // implementation of isCorrectAnswer
                // mov esp, ebp
                // pop ebp
                // ret
            // test eax, eax
        // jz .LElse
            // push [ebp-16] ; noGoSignal
            // call noGoSignalHappened
            // push ebp
            // mov ebp, esp
            // implementation
            // mov esp, ebp
            // pop ebp
            // ret
            // test eax, eax
            // jnz .LCheckUserAnswer
            // jmp .LElse

            // .LCheckUserAnswer:
            // push dword ptr [edx + 8] ; reverseCCTGame->answer
            // call userDidNotAnswer
            // push ebp
            // mov ebp, esp
            // implementation
            // mov esp, ebp
            // pop ebp
            // ret
            // test eax, eax
            // jz .LElse

            previousAnswerCorrect = 1;
            // mov dword ptr [ebp-4], 1

            validStreak = increaseStreak(validStreak);
            // push dword ptr [ebp-8]
            // call increaseStreak
                // push ebp
                // mov ebp, esp
                // implementation
                // mov esp, ebp
                // pop ebp
                // ret
            // mov dword ptr [ebp-8], eax
            errorStreak = 0;
            // mov dword ptr [ebp-12], 0

        } else {
            previousAnswerCorrect = 0;
            // mov dword ptr [ebp-4], 0

            errorStreak = increaseStreak(errorStreak);
            // push dword ptr [ebp-12]
            // call increaseStreak
                // push ebp
                // mov ebp, esp
                // implementation
                // mov esp, ebp
                // pop ebp
                // ret
            // mov dword ptr [ebp-12], eax

            validStreak = 0;
            // mov dword ptr [ebp-8], 0
        }
        // push eax
        // call system
        system("cls");
        
    }
    // jmp .Lwhile
    free(reverseCCTGame);
    // pop edi (callee-saved restore)
    // pop esi (callee-saved restore)
    // pop ebp
    // ret
    return 0;
}
